// Código C del Sistema de Lógica Difusa

// Automatically generated by UNFUZZY V 3.0
// Author: Oscar Duarte (ogduartev@unal.edu.co)
// Universidad Nacional de Colombia
// Disclaimer: 
// The code generated is udes under the responsability of the user.
// It does not causes direct or indirect responsability neither for the author of UNFUZZY
// nor for Universidad Nacional de Colombia.
// 
// para compilar el archivo xxx.c:
//   g++ xxx.c

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <iostream>
#include <string>
using namespace std;

#define NUMEROREGLAS                 15
#define NUMEROVARIABLESENTRADA       2
#define NUMEROVARIABLESSALIDA        1
#define NUMEROTOTALCONJUNTOSENTRADA  8

struct conjunto{
	string nombre;
	double minimo;
	double maximo;
};

struct variable{
	string nombre;
	double minimo;
	double maximo;
	int intervalos;
	double intervalo;
	int numeroConjuntos;
};

struct difusor{
	double minimo;
	double maximo;
	double centro;
	double var1;
	double var2;
	double var3;
	double var4;
	int puntos;
	double intervalo;
};

struct variable VariablesEntrada[NUMEROVARIABLESENTRADA];
struct variable VariablesSalida[NUMEROVARIABLESSALIDA];
struct conjunto Entradas[NUMEROTOTALCONJUNTOSENTRADA];
struct difusor Difusores[NUMEROTOTALCONJUNTOSENTRADA];
int Reglas[NUMEROREGLAS][NUMEROVARIABLESENTRADA+NUMEROVARIABLESSALIDA];
double Modificadores[NUMEROREGLAS][NUMEROVARIABLESENTRADA];
double CentrosAltura[NUMEROREGLAS][NUMEROVARIABLESSALIDA];
void llenarDatos();
void llenarVariablesEntrada();
void llenarVariablesSalida();
void llenarEntradas();
void llenarDifusores();
void llenarReglas();
void llenarModificadores();
void llenarCentrosAltura();
void calcular(double *ent,double *sal);
double salidaConcreta(int NumeroSalida, double *entra);
double salidaConcreta0(double *entra);

double pertenenciaComposicion(int numVar, int numRegla, double sal);
double pertenenciaDifusores(double *ent);
double pertenenciaImplicacion(int numSal, int numRegla,double *ent, double sal);
double pertenenciaConsecuente(int numSal, int numRegla, double sal);
double pertenenciaAntecedente(int numRegla, double *ent);
int activarRegla(int numRegla);
double pertenenciaDifusor(int numVar, double x);
double pertenenciaVariableEntrada(int numVar,int numConj, double x);
double pertenenciaVariableSalida(int numVar,int numConj, double x);

int indiceEntradas(int numRegla,int numVar);
void actualizarEntradas(double *ent);
double Implicacion(double x,double y);
double Composicion(double x,double y);
double Conjuncion(double x,double y);
double And(double x,double y);

int main()
{
    double entra[NUMEROVARIABLESENTRADA];
    double sale[NUMEROVARIABLESSALIDA];
    char q='s';
    llenarDatos();
    while(q=='s')
    {
        int i;
        for(i=0;i<NUMEROVARIABLESENTRADA;i++)
        {
            double e;
            printf("%s : ",VariablesEntrada[i].nombre.c_str());
            scanf("%lf",&e);
            entra[i]=e;
        }
        calcular(entra,sale);
        for(i=0;i<NUMEROVARIABLESSALIDA;i++)
        {
            printf("%s : ",VariablesSalida[i].nombre.c_str());
            printf("%lf : \n",sale[i]);
        }
        printf("Desea otro cálculo ?(s/n)");
        fflush(stdin);
        scanf(" %c",&q);
    }
}
void llenarDatos()
{
    llenarVariablesEntrada();
    llenarVariablesSalida();
    llenarEntradas();
    llenarDifusores();
    llenarReglas();
    llenarModificadores();
    llenarCentrosAltura();
}
void calcular(double *entra, double *sale)
{
    int i;
    for(i=0;i<NUMEROVARIABLESSALIDA;i++)
    {
        sale[i]=salidaConcreta(i,entra);
    }
}
void actualizarEntradas(double *ent)
{
    double dx;
    int i;
    for(i=0;i<NUMEROVARIABLESENTRADA;i++)
    {
        dx=ent[i]-Difusores[i].centro;
        Difusores[i].centro=Difusores[i].centro+dx;
        Difusores[i].minimo=Difusores[i].minimo+dx;
        Difusores[i].maximo=Difusores[i].maximo+dx;
        Difusores[i].var1=Difusores[i].var1+dx;
        Difusores[i].var2=Difusores[i].var2+dx;
        Difusores[i].var3=Difusores[i].var3+dx;
        Difusores[i].var4=Difusores[i].var4+dx;
    }
}
int indiceEntradas(int numVar,int numConj)
{
    int contador=0;
    int i;
    for(i=0;i<numVar;i++)
    {
        contador=contador+VariablesEntrada[i].numeroConjuntos;
    }
    contador=contador+numConj;
    return contador;
}
double pertenenciaComposicion(int numVar,int numRegla, double sal)
{
    double ux;
    double uxa;
    double uxab;
    double comp=0;
    double x[NUMEROVARIABLESENTRADA];
    int inter[NUMEROVARIABLESENTRADA];
    if(!activarRegla(numRegla))
    {
        comp=Implicacion(0,0);
    }
    else{
        int casos=1;
        int i;
        for(i=0;i<NUMEROVARIABLESENTRADA;i++)
        {
            casos=casos*Difusores[i].puntos;
            inter[i]=1;
        }
        for(i=0;i<NUMEROVARIABLESENTRADA;i++)
        {
            int k;
            for(k=0;k<NUMEROVARIABLESENTRADA;k++)
            {
                x[k]=Difusores[k].minimo+Difusores[k].intervalo*inter[k];
                inter[k]=inter[k]+1;
                if(inter[k]>=Difusores[k].puntos)
                {
                    inter[k]=1;
                }
            }
            uxab=pertenenciaImplicacion(numVar,numRegla,x,sal);
            uxa=pertenenciaDifusores(x);
            ux=Composicion(uxa,uxab);
            if(ux>comp)
            {
                comp=ux;
            }
        }
    }
    return comp;
}
double pertenenciaDifusores(double *ent)
{
    double uxd;
    int j=0;
    uxd=pertenenciaDifusor(j,ent[j]);
    for(j=0;j<NUMEROVARIABLESENTRADA;j++)
    {
    uxd=And(uxd,pertenenciaDifusor(j,ent[j]));
    }
    return uxd;
}
double pertenenciaImplicacion(int numSal,int numRegla,double *ent,double sal)
{
    double uxa,uxb;
    uxa=pertenenciaAntecedente(numRegla,ent);
    uxb=pertenenciaConsecuente(numSal,numRegla,sal);
    return Implicacion(uxa,uxb);
}
double pertenenciaConsecuente(int numSal,int numRegla,double sal)
{
    double uxc;
    int conj;
    conj=Reglas[numRegla][NUMEROVARIABLESENTRADA+numSal];
    uxc=pertenenciaVariableSalida(numSal,conj,sal);
    return uxc;
}
double pertenenciaAntecedente(int numRegla,double *ent)
{
    double ux;
    double uxa;
    int conj;
    int j=0;
    conj=Reglas[numRegla][0];
    ux=pertenenciaVariableEntrada(j,conj,ent[j]);
    if(Modificadores[numRegla][0]>0.0)
    {
        uxa=pow(ux,Modificadores[numRegla][0]);
    }else
    {
        uxa=1;
    }
    for(j=1;j<NUMEROVARIABLESENTRADA;j++)
    {
        conj=Reglas[numRegla][j];
        ux=pertenenciaVariableEntrada(j,conj,ent[j]);
        if(Modificadores[numRegla][j]>0.0)
        {
            ux=pow(ux,Modificadores[numRegla][j]);
        }else
        {
            ux=1;
        }
        uxa=And(uxa,ux);
    }
    return uxa;
}
int activarRegla(int numRegla)
{
    int i;
    for(i=0;i<NUMEROVARIABLESENTRADA;i++)
    {
        double bmn,bmx,cmn,cmx;
        int numCon;
        int indice;
        numCon=Reglas[numRegla][i];
        indice=indiceEntradas(i,numCon);
        bmn=Entradas[indice].minimo;
        bmx=Entradas[indice].maximo;
        cmn=Difusores[i].minimo;
        cmx=Difusores[i].maximo;
        if(bmn>cmx||bmx<cmn)
            return 0;
    }
    return 1;
}
double salidaConcreta(int NumeroSalida,double *ent)
{
    double respuesta;
    switch(NumeroSalida)
    {
        case 0 : respuesta=salidaConcreta0(ent);break;
        default:respuesta=0;break;
    }
    return respuesta;
}
double salidaConcreta0(double *ent)
{
    int NumeroSalida=0;
    double con=0;
    double y;
    double y1=0;
    double y2=0;
    double ymax;
    int i;
    int j;
    ymax=VariablesSalida[NumeroSalida].minimo;
    actualizarEntradas(ent);
    for(i=0;i<(VariablesSalida[NumeroSalida].intervalos+1);i++)
    {
        double con=0;
        y=VariablesSalida[NumeroSalida].minimo+i*VariablesSalida[NumeroSalida].intervalo;
        for(j=0;j<NUMEROREGLAS;j++)
        {
            double temp;
            temp=pertenenciaComposicion(NumeroSalida,j,y);
            con=Conjuncion(con,temp);
        }
        y1=y1+y*con;
        y2=y2+con;
    }
    if(fabs(y2)<0.000001)
        y2=100000.0;
    if(fabs(y1)<0.000001)
        y1=0.0;
    ymax=y1/y2;
    return ymax;
}

void llenarVariablesEntrada()
{
    VariablesEntrada[0].nombre="Ángulo";
    VariablesEntrada[0].minimo=-1;
    VariablesEntrada[0].maximo=1;
    VariablesEntrada[0].intervalos=30;
    VariablesEntrada[0].intervalo=0.0666667;
    VariablesEntrada[0].numeroConjuntos=5;

    VariablesEntrada[1].nombre="Delta Ángulo";
    VariablesEntrada[1].minimo=-1;
    VariablesEntrada[1].maximo=1;
    VariablesEntrada[1].intervalos=20;
    VariablesEntrada[1].intervalo=0.1;
    VariablesEntrada[1].numeroConjuntos=3;

}

void llenarVariablesSalida()
{
    VariablesSalida[0].nombre="Control";
    VariablesSalida[0].minimo=-1;
    VariablesSalida[0].maximo=1;
    VariablesSalida[0].intervalos=30;
    VariablesSalida[0].intervalo=0.0666667;
    VariablesSalida[0].numeroConjuntos=5;

}
void llenarEntradas()
{
    Entradas[0].minimo=-1;
    Entradas[0].maximo=-0.333333;

    Entradas[1].minimo=-0.666667;
    Entradas[1].maximo=0;

    Entradas[2].minimo=-0.333333;
    Entradas[2].maximo=0.333333;

    Entradas[3].minimo=0;
    Entradas[3].maximo=0.666667;

    Entradas[4].minimo=0.333333;
    Entradas[4].maximo=1;

    Entradas[5].minimo=-1;
    Entradas[5].maximo=0;

    Entradas[6].minimo=-0.5;
    Entradas[6].maximo=0.5;

    Entradas[7].minimo=0;
    Entradas[7].maximo=1;

}
void llenarDifusores()
{
    Difusores[0].minimo=0.995;
    Difusores[0].maximo=1.005;
    Difusores[0].centro=1;
    Difusores[0].puntos=1;
    Difusores[0].intervalo=0.005;
    Difusores[0].var1=0.995;
    Difusores[0].var2=1.005;
    Difusores[0].var3=0;
    Difusores[0].var4=0;

    Difusores[1].minimo=0.495;
    Difusores[1].maximo=0.505;
    Difusores[1].centro=0.5;
    Difusores[1].puntos=1;
    Difusores[1].intervalo=0.005;
    Difusores[1].var1=0.495;
    Difusores[1].var2=0.505;
    Difusores[1].var3=0;
    Difusores[1].var4=0;

}
void llenarReglas()
{
    Reglas[0][0]=0;
    Reglas[0][1]=0;
    Reglas[0][2]=0;

    Reglas[1][0]=0;
    Reglas[1][1]=1;
    Reglas[1][2]=0;

    Reglas[2][0]=0;
    Reglas[2][1]=2;
    Reglas[2][2]=1;

    Reglas[3][0]=1;
    Reglas[3][1]=0;
    Reglas[3][2]=1;

    Reglas[4][0]=1;
    Reglas[4][1]=1;
    Reglas[4][2]=1;

    Reglas[5][0]=1;
    Reglas[5][1]=2;
    Reglas[5][2]=2;

    Reglas[6][0]=2;
    Reglas[6][1]=0;
    Reglas[6][2]=2;

    Reglas[7][0]=2;
    Reglas[7][1]=1;
    Reglas[7][2]=2;

    Reglas[8][0]=2;
    Reglas[8][1]=2;
    Reglas[8][2]=2;

    Reglas[9][0]=3;
    Reglas[9][1]=0;
    Reglas[9][2]=2;

    Reglas[10][0]=3;
    Reglas[10][1]=1;
    Reglas[10][2]=3;

    Reglas[11][0]=3;
    Reglas[11][1]=2;
    Reglas[11][2]=3;

    Reglas[12][0]=4;
    Reglas[12][1]=0;
    Reglas[12][2]=3;

    Reglas[13][0]=4;
    Reglas[13][1]=1;
    Reglas[13][2]=4;

    Reglas[14][0]=4;
    Reglas[14][1]=2;
    Reglas[14][2]=4;

}

void llenarModificadores()
{
    Modificadores[0][0]=1;
    Modificadores[0][1]=1;
    Modificadores[1][0]=1;
    Modificadores[1][1]=1;
    Modificadores[2][0]=1;
    Modificadores[2][1]=1;
    Modificadores[3][0]=1;
    Modificadores[3][1]=1;
    Modificadores[4][0]=1;
    Modificadores[4][1]=1;
    Modificadores[5][0]=1;
    Modificadores[5][1]=1;
    Modificadores[6][0]=1;
    Modificadores[6][1]=1;
    Modificadores[7][0]=1;
    Modificadores[7][1]=1;
    Modificadores[8][0]=1;
    Modificadores[8][1]=1;
    Modificadores[9][0]=1;
    Modificadores[9][1]=1;
    Modificadores[10][0]=1;
    Modificadores[10][1]=1;
    Modificadores[11][0]=1;
    Modificadores[11][1]=1;
    Modificadores[12][0]=1;
    Modificadores[12][1]=1;
    Modificadores[13][0]=1;
    Modificadores[13][1]=1;
    Modificadores[14][0]=1;
    Modificadores[14][1]=1;
}
void llenarCentrosAltura()
{
    CentrosAltura[0][0]=-0.833333;
    CentrosAltura[1][0]=-0.833333;
    CentrosAltura[2][0]=-0.333333;
    CentrosAltura[3][0]=-0.333333;
    CentrosAltura[4][0]=-0.333333;
    CentrosAltura[5][0]=0;
    CentrosAltura[6][0]=0;
    CentrosAltura[7][0]=0;
    CentrosAltura[8][0]=0;
    CentrosAltura[9][0]=0;
    CentrosAltura[10][0]=0.333333;
    CentrosAltura[11][0]=0.333333;
    CentrosAltura[12][0]=0.333333;
    CentrosAltura[13][0]=0.833333;
    CentrosAltura[14][0]=0.833333;
}

double pertenenciaDifusor(int numVar, double x)
{
    double ux=0;
    switch(numVar)
    {
        case 0:
            if(x<Difusores[0].var1)
            	ux=0;
            if(x<Difusores[0].var2&&x>=Difusores[0].var1)
            	ux=1;
            if(x>=Difusores[0].var2)
            	ux=0;
            break;
        case 1:
            if(x<Difusores[1].var1)
            	ux=0;
            if(x<Difusores[1].var2&&x>=Difusores[1].var1)
            	ux=1;
            if(x>=Difusores[1].var2)
            	ux=0;
            break;
        default:break;
    }
    return ux;
}
double pertenenciaVariableEntrada(int numVar,int numConj, double x)
{
    double ux=0;
    switch(numVar)
    {
        case 0:
            switch(numConj)
            {
            case 0:
                        if(x<(-1))
                            ux=1;
                        if(x<(-0.666667)&&x>=(-1))
                            ux=1;
                        if(x<(-0.333333)&&x>=(-0.666667))
                            ux=((-0.333333)-x)/((-0.333333)-(-0.666667));
                        if(x>=(-0.333333))
                            ux=0;
                        if(ux<0.0001)
                            ux=0;
                break;
            case 1:
                        if(x<(-0.666667))
                            ux=0;
                        if(x<(-0.333333)&&x>=(-0.666667))
                            ux=(x-(-0.666667))/((-0.333333)-(-0.666667));
                        if(x<(0)&&x>=(-0.333333))
                            ux=((0)-x)/((0)-(-0.333333));
                        if(x>=(0))
                            ux=0;
                        if(ux<0.0001)
                            ux=0;

                break;
            case 2:
                        if(x<(-0.333333))
                            ux=0;
                        if(x<(0)&&x>=(-0.333333))
                            ux=(x-(-0.333333))/((0)-(-0.333333));
                        if(x<(0.333333)&&x>=(0))
                            ux=((0.333333)-x)/((0.333333)-(0));
                        if(x>=(0.333333))
                            ux=0;
                        if(ux<0.0001)
                            ux=0;

                break;
            case 3:
                        if(x<(0))
                            ux=0;
                        if(x<(0.333333)&&x>=(0))
                            ux=(x-(0))/((0.333333)-(0));
                        if(x<(0.666667)&&x>=(0.333333))
                            ux=((0.666667)-x)/((0.666667)-(0.333333));
                        if(x>=(0.666667))
                            ux=0;
                        if(ux<0.0001)
                            ux=0;

                break;
            case 4:
                        if(x<(0.333333))
                            ux=0;
                        if(x<(0.666667)&&x>=(0.333333))
                            ux=(x-(0.333333))/((0.666667)-(0.333333));
                        if(x>=(0.666667))
                            ux=1;
                        if(ux<0.0001)
                            ux=0;
                break;
            default:break;
            }break;
        case 1:
            switch(numConj)
            {
            case 0:
                        if(x<(-1))
                            ux=1;
                        if(x<(-0.5)&&x>=(-1))
                            ux=1;
                        if(x<(0)&&x>=(-0.5))
                            ux=((0)-x)/((0)-(-0.5));
                        if(x>=(0))
                            ux=0;
                        if(ux<0.0001)
                            ux=0;
                break;
            case 1:
                        if(x<(-0.5))
                            ux=0;
                        if(x<(0)&&x>=(-0.5))
                            ux=(x-(-0.5))/((0)-(-0.5));
                        if(x<(0.5)&&x>=(0))
                            ux=((0.5)-x)/((0.5)-(0));
                        if(x>=(0.5))
                            ux=0;
                        if(ux<0.0001)
                            ux=0;

                break;
            case 2:
                        if(x<(0))
                            ux=0;
                        if(x<(0.5)&&x>=(0))
                            ux=(x-(0))/((0.5)-(0));
                        if(x>=(0.5))
                            ux=1;
                        if(ux<0.0001)
                            ux=0;
                break;
            default:break;
            }break;
        default:break;
    }
    return ux;
}
double pertenenciaVariableSalida(int numVar,int numConj, double x)
{
    double ux=0;
    switch(numVar)
    {
        case 0:
            switch(numConj)
            {
            case 0:
                        if(x<(-1))
                            ux=1;
                        if(x<(-0.666667)&&x>=(-1))
                            ux=1;
                        if(x<(-0.333333)&&x>=(-0.666667))
                            ux=((-0.333333)-x)/((-0.333333)-(-0.666667));
                        if(x>=(-0.333333))
                            ux=0;
                        if(ux<0.0001)
                            ux=0;
                break;
            case 1:
                        if(x<(-0.666667))
                            ux=0;
                        if(x<(-0.333333)&&x>=(-0.666667))
                            ux=(x-(-0.666667))/((-0.333333)-(-0.666667));
                        if(x<(0)&&x>=(-0.333333))
                            ux=((0)-x)/((0)-(-0.333333));
                        if(x>=(0))
                            ux=0;
                        if(ux<0.0001)
                            ux=0;

                break;
            case 2:
                        if(x<(-0.333333))
                            ux=0;
                        if(x<(0)&&x>=(-0.333333))
                            ux=(x-(-0.333333))/((0)-(-0.333333));
                        if(x<(0.333333)&&x>=(0))
                            ux=((0.333333)-x)/((0.333333)-(0));
                        if(x>=(0.333333))
                            ux=0;
                        if(ux<0.0001)
                            ux=0;

                break;
            case 3:
                        if(x<(0))
                            ux=0;
                        if(x<(0.333333)&&x>=(0))
                            ux=(x-(0))/((0.333333)-(0));
                        if(x<(0.666667)&&x>=(0.333333))
                            ux=((0.666667)-x)/((0.666667)-(0.333333));
                        if(x>=(0.666667))
                            ux=0;
                        if(ux<0.0001)
                            ux=0;

                break;
            case 4:
                        if(x<(0.333333))
                            ux=0;
                        if(x<(0.666667)&&x>=(0.333333))
                            ux=(x-(0.333333))/((0.666667)-(0.333333));
                        if(x>=(0.666667))
                            ux=1;
                        if(ux<0.0001)
                            ux=0;
                break;
            default:break;
            }break;
        default:break;
    }
    return ux;
}
double Implicacion(double x,double y)
{
    double rel;
    if(x<y)
    {
    	rel=x;
    }else
    {
    	rel=y;
    }
    return rel;
}

double Composicion(double x,double y)
{
    double z;
    if(x<y)
    {
    	z=x;
    }else
    {
    	z=y;
    }
    return z;
}

double Conjuncion(double x,double y)
{
    double z;
    if(x>y)
    {
    	z=x;
    }else
    {
    	z=y;
    }
    return z;
}

double And(double x,double y)
{
    double z;
    if(x<y)
    {
    	z=x;
    }else
    {
    	z=y;
    }
    return z;
}

